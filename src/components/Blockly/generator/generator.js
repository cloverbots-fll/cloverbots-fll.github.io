import * as Blockly from 'blockly/core';

export const PyBricksGenerator = new Blockly.Generator('Python (PyBricks)');

// Generator for setting up a motor
PyBricksGenerator.forBlock['motor_initialize'] = function(block, generator) {
  const motorPort = block.getFieldValue('MOTOR');
  return `motor_${motorPort} = Motor(Port.${motorPort})\n`;
};

// Generator for running a motor
PyBricksGenerator.forBlock['motor_run'] = function(block, generator) {
  const motorPort = block.getFieldValue('MOTOR');
  const speed = block.getFieldValue('SPEED');
  const direction = block.getFieldValue('DIRECTION') === 'CLOCKWISE' ? '' : '-';
  const amount = block.getFieldValue('AMOUNT');
  const unit = block.getFieldValue('UNIT');

  if (unit === 'INFINITE') {
    return `motor_${motorPort}.run(${direction}${speed} * 1000)\n`;
  } else if (unit === 'ROTATIONS') {
    return `motor_${motorPort}.run_angle(${direction}${speed} * 1000, ${amount} * 360)\n`;
  } else if (unit === 'DEGREES') {
    return `motor_${motorPort}.run_angle(${direction}${speed} * 1000, ${amount})\n`;
  } else if (unit === 'SECONDS') {
    return `motor_${motorPort}.run_time(${direction}${speed} * 1000, ${amount} * 1000)\n`;
  }
};

// Generator for stopping a motor
PyBricksGenerator.forBlock['motor_stop'] = function(block, generator) {
  const motorPort = block.getFieldValue('MOTOR');
  return `motor_${motorPort}.stop()\n`;
};

// Generator for getting the motor speed variable
PyBricksGenerator.forBlock['motor_speed_var'] = function(block, generator) {
  const motorPort = block.getFieldValue('MOTOR');
  return [`motor_${motorPort}.speed()`, PyBricksGenerator.ORDER_ATOMIC];
};

// Generator for getting the motor position variable
PyBricksGenerator.forBlock['motor_position_var'] = function(block, generator) {
  const motorPort = block.getFieldValue('MOTOR');
  return [`motor_${motorPort}.angle()`, PyBricksGenerator.ORDER_ATOMIC];
};

// Generator for initializing a drivebase
PyBricksGenerator.forBlock['movement_initialize'] = function(block, generator) {
  const leftMotorPort = block.getFieldValue('LEFT_MOTOR');
  const rightMotorPort = block.getFieldValue('RIGHT_MOTOR');
  const speed = block.getFieldValue('SPEED');
  const acceleration = block.getFieldValue('ACCELERATION');
  const wheelDiameter = block.getFieldValue('WHEEL_DIAMETER');
  const wheelSeparation = block.getFieldValue('WHEEL_SEPARATION');
  
  return `
  drive_base = DriveBase(
    Motor(Port.${leftMotorPort}), Motor(Port.${rightMotorPort}),
    ${wheelDiameter}, ${wheelSeparation}
  )
  drive_base.settings(${speed * 10}, ${acceleration * 10})
  `;
};

// Generator for moving the drivebase
PyBricksGenerator.forBlock['movement_run'] = function(block, generator) {
  const direction = block.getFieldValue('DIRECTION') === 'FORWARD' ? '' : '-';
  const amount = block.getFieldValue('AMOUNT');
  const unit = block.getFieldValue('UNIT');

  if (unit === 'INFINITE') {
    return `drive_base.drive(${direction}100, 0)\n`;
  } else if (unit === 'DISTANCE') {
    return `drive_base.straight(${direction}${amount})\n`;
  } else if (unit === 'SECONDS') {
    return `drive_base.drive_time(${direction}100, 0, ${amount} * 1000)\n`;
  }
};

// Generator for stopping the drivebase
PyBricksGenerator.forBlock['movement_stop'] = function() {
  return 'drive_base.stop()\n';
};

// Generator for the main event
PyBricksGenerator.forBlock['events_main'] = function() {
  return '# NOTE: This program was automatically generated by the PyBricks Block Generator\n';
};

// Generator for waiting
PyBricksGenerator.forBlock['controls_wait_seconds'] = function(block, generator) {
  const seconds = block.getFieldValue('SECONDS');
  return `wait(${seconds} * 1000)\n`;
};

// Generator for repeating a block a number of times
PyBricksGenerator.forBlock['controls_repeat_times'] = function(block, generator) {
  const times = block.getFieldValue('TIMES');
  const statements = PyBricksGenerator.statementToCode(block, 'DO');
  return `for _ in range(${times}):\n${PyBricksGenerator.prefixLines(statements, PyBricksGenerator.INDENT)}`;
};

// Generator for repeating blocks indefinitely
PyBricksGenerator.forBlock['controls_forever'] = function(block, generator) {
  const statements = PyBricksGenerator.statementToCode(block, 'DO');
  return `while True:\n${PyBricksGenerator.prefixLines(statements, PyBricksGenerator.INDENT)}`;
};

// Generator for repeating until a condition is met
PyBricksGenerator.forBlock['controls_repeat_until'] = function(block, generator) {
  const condition = PyBricksGenerator.valueToCode(block, 'CONDITION', PyBricksGenerator.ORDER_NONE) || 'False';
  const statements = PyBricksGenerator.statementToCode(block, 'DO');
  return `while not (${condition}):\n${PyBricksGenerator.prefixLines(statements, PyBricksGenerator.INDENT)}`;
};

// Generator for an if statement
PyBricksGenerator.forBlock['controls_if'] = function(block, generator) {
  const condition = PyBricksGenerator.valueToCode(block, 'IF0', PyBricksGenerator.ORDER_NONE) || 'False';
  const statements = PyBricksGenerator.statementToCode(block, 'DO0');
  return `if ${condition}:\n${PyBricksGenerator.prefixLines(statements, PyBricksGenerator.INDENT)}`;
};

PyBricksGenerator.forBlock['controls_if_else'] = function(block, generator) {
  const condition = PyBricksGenerator.valueToCode(block, 'IF0', PyBricksGenerator.ORDER_NONE) || 'False';
  const ifBranch = PyBricksGenerator.statementToCode(block, 'DO0');
  const elseBranch = PyBricksGenerator.statementToCode(block, 'ELSE');
  const code = `if ${condition}:\n${ifBranch}else:\n${elseBranch}`;
  return code;
};

PyBricksGenerator.forBlock['controls_wait_until'] = function(block, generator) {
  const condition = PyBricksGenerator.valueToCode(block, 'CONDITION', PyBricksGenerator.ORDER_NONE) || 'False';
  const code = `while not (${condition}):\n  pass\n`;
  return code;
};

PyBricksGenerator.forBlock['controls_stop'] = function(block, generator) {
  return 'exit()\n';
};

PyBricksGenerator.forBlock['controls_function'] = function(block, generator) {
  const functionName = block.getFieldValue('NAME');
  const args = block.getFieldValue('ARGS');
  const code = `def ${functionName}(${args}):\n  pass\n`;
  return code;
};

PyBricksGenerator.forBlock['sensor_is_color'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const color = block.getFieldValue('COLOR');
  const code = `sensor_${port}.is_color('${color}')`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_reflection'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const threshold = block.getFieldValue('THRESHOLD');
  const code = `sensor_${port}.reflection < ${threshold}`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_color'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const code = `sensor_${port}.color()`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_reflected_light'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const code = `sensor_${port}.reflected_light()`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_is_pressed'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const code = `sensor_${port}.is_pressed()`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_pressure'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const code = `sensor_${port}.pressure()`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_is_closer_than'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const distance = block.getFieldValue('DISTANCE');
  const code = `sensor_${port}.is_closer_than(${distance})`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_distance'] = function(block, generator) {
  const port = block.getFieldValue('PORT');
  const code = `sensor_${port}.distance()`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_reset_yaw_angle'] = function(block, generator) {
  return 'reset_yaw_angle()\n';
};

PyBricksGenerator.forBlock['sensor_yaw_angle'] = function(block, generator) {
  return ['get_yaw_angle()', PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_is_button_pressed'] = function(block, generator) {
  const button = block.getFieldValue('BUTTON');
  const code = `is_${button}_button_pressed()`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_timer'] = function(block, generator) {
  return ['get_timer()', PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['sensor_reset_timer'] = function(block, generator) {
  return 'reset_timer()\n';
};

PyBricksGenerator.forBlock['operator_pick_random'] = function(block, generator) {
  const from = block.getFieldValue('FROM');
  const to = block.getFieldValue('TO');
  const code = `random.randint(${from}, ${to})`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['operator_and'] = function(block, generator) {
  const a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_NONE) || 'False';
  const b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_NONE) || 'False';
  const code = `${a} and ${b}`;
  return [code, PyBricksGenerator.ORDER_LOGICAL_AND];
};

PyBricksGenerator.forBlock['operator_or'] = function(block, generator) {
  const a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_NONE) || 'False';
  const b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_NONE) || 'False';
  const code = `${a} or ${b}`;
  return [code, PyBricksGenerator.ORDER_LOGICAL_OR];
};

PyBricksGenerator.forBlock['operator_join'] = function(block, generator) {
  const add0 = PyBricksGenerator.valueToCode(block, 'ADD0', PyBricksGenerator.ORDER_ATOMIC) || '""';
  const add1 = PyBricksGenerator.valueToCode(block, 'ADD1', PyBricksGenerator.ORDER_ATOMIC) || '""';
  const code = `${add0} + ${add1}`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['operator_not'] = function(block, generator) {
  const bool = PyBricksGenerator.valueToCode(block, 'BOOL', PyBricksGenerator.ORDER_NONE) || 'False';
  const code = `not ${bool}`;
  return [code, PyBricksGenerator.ORDER_LOGICAL_NOT];
};

PyBricksGenerator.forBlock['operator_is_between'] = function(block, generator) {
  const value = PyBricksGenerator.valueToCode(block, 'VALUE', PyBricksGenerator.ORDER_NONE) || '0';
  const from = block.getFieldValue('FROM');
  const to = block.getFieldValue('TO');
  const code = `(${from} <= ${value} <= ${to})`;
  return [code, PyBricksGenerator.ORDER_RELATIONAL];
};

PyBricksGenerator.forBlock['operator_char_at'] = function(block, generator) {
  const value = PyBricksGenerator.valueToCode(block, 'VALUE', PyBricksGenerator.ORDER_NONE) || '""';
  const at = block.getFieldValue('AT');
  const code = `${value}[${at} - 1]`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['operator_length'] = function(block, generator) {
  const value = PyBricksGenerator.valueToCode(block, 'VALUE', PyBricksGenerator.ORDER_NONE) || '""';
  const code = `len(${value})`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['operator_contains'] = function(block, generator) {
  const value = PyBricksGenerator.valueToCode(block, 'VALUE', PyBricksGenerator.ORDER_NONE) || '""';
  const text = block.getFieldValue('TEXT');
  const code = `${text} in ${value}`;
  return [code, PyBricksGenerator.ORDER_ATOMIC];
};

PyBricksGenerator.forBlock['math_add'] = function(block, generator) {
  const a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_NONE) || '0';
  const b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_NONE) || '0';
  const code = `${a} + ${b}`;
  return [code, PyBricksGenerator.ORDER_ADDITIVE];
};

PyBricksGenerator.forBlock['math_subtract'] = function(block, generator) {
  const a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_NONE) || '0';
  const b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_NONE) || '0';
  const code = `${a} - ${b}`;
  return [code, PyBricksGenerator.ORDER_ADDITIVE];
};

PyBricksGenerator.forBlock['math_multiply'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_MULTIPLICATIVE) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_MULTIPLICATIVE) || '0';
  var code = value_a + ' * ' + value_b;
  return [code, PyBricksGenerator.ORDER_MULTIPLICATIVE];
};

PyBricksGenerator.forBlock['math_divide'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_MULTIPLICATIVE) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_MULTIPLICATIVE) || '1';
  var code = value_a + ' / ' + value_b;
  return [code, PyBricksGenerator.ORDER_MULTIPLICATIVE];
};

PyBricksGenerator.forBlock['math_less_than'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var code = value_a + ' < ' + value_b;
  return [code, PyBricksGenerator.ORDER_RELATIONAL];
};

PyBricksGenerator.forBlock['math_equal'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var code = value_a + ' == ' + value_b;
  return [code, PyBricksGenerator.ORDER_RELATIONAL];
};

PyBricksGenerator.forBlock['math_not_equal'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var code = value_a + ' != ' + value_b;
  return [code, PyBricksGenerator.ORDER_RELATIONAL];
};

PyBricksGenerator.forBlock['math_greater_than'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_RELATIONAL) || '0';
  var code = value_a + ' > ' + value_b;
  return [code, PyBricksGenerator.ORDER_RELATIONAL];
};

PyBricksGenerator.forBlock['math_round'] = function(block, generator) {
  var value_num = PyBricksGenerator.valueToCode(block, 'NUM', PyBricksGenerator.ORDER_NONE) || '0';
  var code = 'round(' + value_num + ')';
  return [code, PyBricksGenerator.ORDER_FUNCTION_CALL];
};

PyBricksGenerator.forBlock['math_modulus'] = function(block, generator) {
  var value_a = PyBricksGenerator.valueToCode(block, 'A', PyBricksGenerator.ORDER_MULTIPLICATIVE) || '0';
  var value_b = PyBricksGenerator.valueToCode(block, 'B', PyBricksGenerator.ORDER_MULTIPLICATIVE) || '1';
  var code = value_a + ' % ' + value_b;
  return [code, PyBricksGenerator.ORDER_MULTIPLICATIVE];
};

PyBricksGenerator.forBlock['math_functions'] = function(block, generator) {
  var dropdown_function = block.getFieldValue('FUNCTION');
  var number_num = block.getFieldValue('NUM') || '0';
  var function_map = {
    'ABS': 'abs',
    'FLOOR': 'math.floor',
    'CEILING': 'math.ceil',
    'SQRT': 'math.sqrt',
    'SIN': 'math.sin',
    'COS': 'math.cos',
    'TAN': 'math.tan',
    'ASIN': 'math.asin',
    'ACOS': 'math.acos',
    'ATAN': 'math.atan',
    'LN': 'math.log',
    'LOG': 'math.log10',
    'EXP': 'math.exp',
    'TENEXP': '10 **'
  };
  var code = function_map[dropdown_function] + '(' + number_num + ')';
  return [code, PyBricksGenerator.ORDER_FUNCTION_CALL];
};

PyBricksGenerator.forBlock['comment'] = function(block, generator) {
  var text_comment = block.getFieldValue('COMMENT');
  var code = '# ' + text_comment + '\n';
  return code;
};

PyBricksGenerator.forBlock['multiline_comment'] = function(block, generator) {
  var text_comment = block.getFieldValue('COMMENT');
  var code = '"""' + text_comment + '"""\n';
  return code;
};